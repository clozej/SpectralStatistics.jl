var documenterSearchIndex = {"docs":
[{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the the SpectralStatistics.jl library - a Julia package for computing and analyzing the statistical properties of quantum spectra.  ","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Spectral statistics are a useful tool for analyzing and classifying the dynamical properties of quantum systems. The statistic featured in this library are most commonly used to study quantum chaos and integrability and quantum-classical correspondence. The aim of the package is to provide efficient, user-friendly and extensively tested implementations of the most widely used spectral statistics and analytical models that describe them in various settings. We hope the package will be useful to seasoned veterans of quantum chaos as well as new entrants into the field. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Tutorial section explains how to get started using SpectralStatistics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the API section for the complete documentation on all the exported types and functions. ","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Compute the most commonly used spectral statistics of real quantum spectra.\nCompare and fit analytical expressions derived from dynamical and random matrix theory models.","category":"page"},{"location":"#News","page":"Home","title":"News","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the first version of the SpectralStatistics.jl package.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This section will guide you through everything you need to know for getting started with the SpectralStatistics.jl package.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Quantum chaos\nTo learn more about spectral statistics and quantum chaos in general the books Quantum Chaos: An Introduction by H.-J. St√∂ckmann  and Quantum Signatures of Chaos by F. Haake are a good place to start.","category":"page"},{"location":"tutorial/#Installation","page":"Tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SpectralStatistics can be installed using the Julia package manager. Simply run:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg; Pkg.add(\"SpectralStatistics\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This will instal the package to your current environment. To use it run:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using SpectralStatistics","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"in your Julia session.","category":"page"},{"location":"tutorial/#Core-components","page":"Tutorial","title":"Core components","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There are three major components of the package:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Types that represent spectral data, for example UnfoldedSpectrum and RealSpectrum. These are subtypes of the DataSample abstract type.\nTypes that represent analytical models of spectral statistics for example Poisson and GOE. These are subtypes of the Model abstract type.\nFunctions that compute the spectral statistics for example level_spacing_pdf. They can be used either to compute the spectral statistics from a spectrum by imputing the data or evaluate an analytical expression from a model. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The package also includes convenience codes for fitting the models to data and plotting.","category":"page"},{"location":"tutorial/#Preparing-and-unfolding-spectra","page":"Tutorial","title":"Preparing and unfolding spectra","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Infinite potential wells are usually one of the first example quantum systems one encounters when learning quantum mechanics. We will analyze the spectrum of a two-dimensional well, namely the rectangular quantum billiard. Let us take a rectangle with sides a and b. The energy levels are given by ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"E_n_x n_y = fracpi^22left(left(fracn_xaright)^2+left(fracn_ybright)^2right)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where n_x and n_y are integer quantum numbers and the particle mass m=1 and hbar=1. We will also fix a=1 and define the ratio chi=ba. We define a function that returns the first N levels:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"H(nx,ny,a,b) = 0.5*pi^2.0*( (nx/a)^2.0 + (ny/b)^2.0 )\n\nfunction rectangle_spectrum(N; chi = 1.0*MathConstants.golden)\n    M = Int(round(10*chi*sqrt(N)))\n    spect = [H(i,j,1.0,chi) for i in 1:M for j in 1:M]\n    return sort(spect)[1:N]\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We set the parameter chi to the golden ratio by default. Let us compute the spectrum of the first 50000 levels:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"spect = rectangle_spectrum(50000)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The SpectralStatistics.jl package uses the RealSpectrum container to represent raw spectral data. This is the data we would obtain form an experiment or a numerical simulation. We pass our data to the container:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"real = RealSpectrum(spect)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Some spectral statistics may be computed directly from this data. Usually, to compare the universal statistical properties of the spectra of different systems, the spectra must first be normalized in an appropriate way. This process is called spectral unfolding. The density of states varies from system to system. The spectral staircase function number of levels up to some energy","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"N(E) = nE_nE","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We are mainly interested in the fluctuations of levels around the local mean that turn out to have universal properties that are related to the dynamics. One way to unfold the spectrum, is to fit a smooth curve F(E) to the spectral staircase. This represents the integrated density of states. One of the common ways of unfolding the spectrum is to transform the spectral data by","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"e_n = F(E_n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The new energies e_n are called the unfolded energies. The function unfold_spectrum can be used to unfold a real spectrum. It returns a new spectrum of type UnfoldedSpectrum. Polynomials of n-th degrees are commonly used as unfolding functions. We will use a second degree polynomial to unfold the billiard spectrum. We simply call:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"unfolded = unfold_spectrum(real, 2)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For convenience it is possible to call unfold_spectrum with an integer as the second parameter to use a polynomial as the fitting function. In general any julia function (its first parameter must be the energy) may be passed as the second parameter of unfold_spectrum and it will be automatically fitted and used as the unfolding function. We have unfolded the spectrum and can now continue with analyzing the spectral statistics.","category":"page"},{"location":"tutorial/#Computing-spectral-statistics","page":"Tutorial","title":"Computing spectral statistics","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let us compute one of the most important and commonly used spectral statistics - the nearest-neighbor level spacing distribution. The level spacings are simply the differences between consecutive energies in the spectrum","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"s_i=e_i+1-e_i","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If the spectrum is unfolded the mean level spacing will be equal to 1. It is possible to compute the level spacings with the level_spacing function. Let us check the unfolding by calling:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Statistics\nmean(level_spacing(unfolded))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We see the mean level spacing is indeed approximately equal to 1. Next we are interested in the probability distribution of finding a certain level spacing in the unfolded spectrum. The level_spacing_pdf computes the probability density function (as a histogram) of the level spacing:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"s = collect(0.0:0.05:5.0)\np = level_spacing_pdf(unfolded, s)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"the second parameter must be a Vector of evaluation points. We can plot the result by using the excellent Makie library:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CairoMakie\nf = Figure(resolution = (640,360))\nax = Axis(f[1,1], xlabel=L\"s\", ylabel=L\"P(s)\")\nlines!(ax,s,p)\nsave(\"lsplot.svg\", f); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/#Using-models","page":"Tutorial","title":"Using models","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We will now compare the results with some analytical models. The library features many of the most used ones. For a complete list see the API section. Let us compare the level spacings with the Poisson model. To initialize a model we call its constructor:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"poisson = Poisson()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can check the characteristics of the model in the documentation Poisson, where we read that it describes the spectral statistics of an integrable system.   This is a parameter-less model so the constructor takes no arguments. The level spacing probability density function for the Poisson model is an exponential decay","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"P(s)=exp(-s)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can evaluate the analytical expression by calling the level_spacing_pdf on the model in the same way as we did for the spectral data:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"p_poisson = level_spacing_pdf(poisson, s)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let us add the result to the plot:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"lines!(ax,s,p_poisson)\nsave(\"lsplot2.svg\", f); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We see the model curve fits the data nicely and we can conclude the rectangular billiard belongs to the class of integrable systems. If this was a real application we might be satisfied with the analysis. However, just to demonstrate how to fit more complicated models we will try describing the data with another. Many models are actually parametric families, where the parameters are given as fields of the Julia type that codes the model. Let's use the Brody model. From the documentation we see this model interpolates between the Poisson and GOE models as the parameter :beta goes form 0.0 to 1.0. We initialize the model by calling:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"brody = Brody()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we initialized the model with the default value of the parameter. We can see from the output this is equal to 1.0. To initialize the model with a different value of the parameter we simply call the constructor with the selected value as an argument: ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"brody = Brody(0.2)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Some models might posses several parameters. One example is the BerryRobnikBrody model. To check all the names of the parameters we can use the fieldnames function on the associated type:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"fieldnames(BerryRobnikBrody)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We see the parameters of this model are called rho and beta. To make sure we do not mix up the order of the parameters we may also initialize the model with keyword arguments corresponding to the names of the parameters:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"brb = BerryRobnikBrody(beta=0.1,rho=0.5)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note from the output that the parameters are initialized correctly regardless of the input order. Usually we want to fit the model to some data in order to find the optimal values of the parameters. We can do this with the fit_model function. This will return a new instance of the model with the adjusted fitting parameter. Since, we have the level spacings already stored we can call:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"brody = fit_model(brody, level_spacing_pdf, s, p)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we chose to overwrite the variable brody with the a new instance with an adjusted parameter value. The second parameter is the statistic we wish to fit. We may also call:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"brody = fit_model(unfolded, brody, level_spacing_pdf)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"to compute the statistic directly from the spectrum if we did not do so beforehand. We see that the fitting parameter is almost 0 and it agrees with the Poisson model.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To learn more about all the features of the library continue by exploring the API section.","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"The following pages document and explain the functionality of all exported types and functions in the library.","category":"page"},{"location":"API/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"API/#Abstract-types","page":"API","title":"Abstract types","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"DataSample\nModel","category":"page"},{"location":"API/#SpectralStatistics.DataSample","page":"API","title":"SpectralStatistics.DataSample","text":"DataSample\n\nDataSample is an abstract supertype encompassing all concrete implementations of  data structures used for processing spectra in the SpectralStatistics.jl library.\n\n\n\n\n\n","category":"type"},{"location":"API/#SpectralStatistics.Model","page":"API","title":"SpectralStatistics.Model","text":"Model\n\nModel is an abstract supertype encompassing all concrete implementations of  the analytical spectral statistics models in the SpectralStatistics.jl library.\n\n\n\n\n\n","category":"type"},{"location":"API/#Data-types","page":"API","title":"Data types","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"RealSpectrum\nUnfoldedSpectrum ","category":"page"},{"location":"API/#SpectralStatistics.RealSpectrum","page":"API","title":"SpectralStatistics.RealSpectrum","text":"RealSpectrum <: DataSample\n\nRealSpectrum is a concrete type used as a container for spectra of real numbers.\n\n\n\n\n\n","category":"type"},{"location":"API/#SpectralStatistics.UnfoldedSpectrum","page":"API","title":"SpectralStatistics.UnfoldedSpectrum","text":"UnfoldedSpectrum <: DataSample\n\nUnfoldedSpectrum is a concrete type used as a container for spectra after unfolding.\n\n\n\n\n\n","category":"type"},{"location":"API/#Spectral-Statistics","page":"API","title":"Spectral Statistics","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"level_spacing\nlevel_spacing_pdf\nlevel_spacing_cdf\nlevel_spacing_u\nnumber_variance\nrigidity\nspectral_form_factor","category":"page"},{"location":"API/#SpectralStatistics.level_spacing","page":"API","title":"SpectralStatistics.level_spacing","text":"level_spacing(spect::UnfoldedSpectrum; n::Int = 1) ‚Üí s::Vector\n\nReturn the level spacings of order n.  The nearest neighbour level spacings are the default, given by n=1.\n\nDescription\n\nThe level spacings of order n are given by the difference between the n-th consecutive levels of the spectrum.  The nearest neighbour level spacing is considered most commonly. \n\nArguments\n\nspect: The unfolded energy spectrum, given as an instance of type UnfoldedSpectrum.\n\nKeyword arguments\n\nn=1 : The order of the level spacings.\n\nReturns\n\ns : Vector of level spacings.\n\n\n\n\n\n","category":"function"},{"location":"API/#SpectralStatistics.level_spacing_pdf","page":"API","title":"SpectralStatistics.level_spacing_pdf","text":"level_spacing_pdf(model::Model, pts::Vector; n::Int = 1) ‚Üí p::Vector\n\nReturn the analytical expression for the level spacing probability density function, corresponding to the chosen model, evaluated at positions pts.\n\nDescription\n\nThe nearest neighbour level spacing distributions are the most commonly studied spectral statistics.\n\nArguments\n\nmodel: The model, given as an instance of a concrete subtype of Model.\npts: The positions where probabability density function should be evaluated.\n\nKeyword arguments\n\nn=1 : The order of the level spacings.\n\nReturns\n\np : Vector of the probabilites.\n\n\n\n\n\nlevel_spacing_pdf(spect::UnfoldedSpectrum, bins::Vector; n::Int = 1) ‚Üí s::Vector p::Vector\n\nReturn a histogram of the probability density function of the level spacings of order n. The nearest neighbour level spacings are the default, given by n=1.\n\nDescription\n\nThe nearest neighbour level spacing distributions are the most commonly studied spectral statistics.\n\nArguments\n\nspect: The unfolded energy spectrum, given as an instance of type UnfoldedSpectrum.\nbins: The boundaries of the bin positions.\n\nKeyword arguments\n\nn=1 : The order of the level spacings.\n\nReturns\n\np : Vector of the probability contained in each bin.\n\n\n\n\n\n","category":"function"},{"location":"API/#SpectralStatistics.level_spacing_cdf","page":"API","title":"SpectralStatistics.level_spacing_cdf","text":"level_spacing_cdf(model::Model, pts::Vector; n::Int = 1) ‚Üí w::Vector\n\nReturn the analytical expression for level spacing cumulative density function, corresponding to the chosen model, evaluated at positions pts.\n\nArguments\n\nmodel: The model, given as an instance of a concrete subtype of Model.\npts: The positions where cumulative density function should be evaluated.\n\nKeyword arguments\n\nn=1 : The order of the level spacings.\n\nReturns\n\nw : Vector of the cumulative probabilities.\n\n\n\n\n\nlevel_spacing_cdf(spect::UnfoldedSpectrum, pts::Vector; n::Int = 1) ‚Üí s::Vector w::Vector\n\nReturn the cumulative density function of the level spacings of order n evaluated at positions pts. The nearest neighbour level spacings are the default, given by n=1.\n\nArguments\n\nspect: The unfolded energy spectrum, given as an instance of type UnfoldedSpectrum.\npts: The positions where cumulative density function should be evaluated.\n\nKeyword arguments\n\nn=1 : The order of the level spacings.\n\nReturns\n\nw : Vector of the cumulative probabilities.\n\n\n\n\n\n","category":"function"},{"location":"API/#SpectralStatistics.level_spacing_u","page":"API","title":"SpectralStatistics.level_spacing_u","text":"level_spacing_u(model::Model, pts::Vector; n::Int = 1) ‚Üí u::Vector\n\nReturn the analytical expression for the spectraly normalized cumulative density function of the nearest neighbour level spacings evaluated at positions pts.\n\nArguments\n\nmodel: The model, given as an instance of a concrete subtype of Model.\npts: The positions where cumulative density function should be evaluated.\n\nKeyword arguments\n\nn=1 : The order of the level spacings.\n\nReturns\n\nu : Vector of the cumulative probabilities.\n\n\n\n\n\nlevel_spacing_u(spect::UnfoldedSpectrum, pts::Vector; n::Int = 1) ‚Üí s::Vector u::Vector\n\nReturn the spectraly normalized cumulative density function of the nearest neighbour level spacings evaluated at positions pts.\n\nDescription\n\nThe nearest neighbour level spacing distributions are the most commonly studied spectral statistics. To normalize the relative fluctuations it is useful to perform the following nonlinear transformation\n\nU(s) = frac2piarccossqrt1-W(s)\n\nwhere W(s) is the cumulative level spacing distribution.\n\nArguments\n\nspect: The unfolded energy spectrum, given as an instance of type UnfoldedSpectrum.\npts: The positions where cumulative density function should be evaluated.\n\nKeyword arguments\n\nn=1 : The order of the level spacings.\n\nReturns\n\nu : Vector of the cumulative probabilities.\n\n\n\n\n\n","category":"function"},{"location":"API/#SpectralStatistics.number_variance","page":"API","title":"SpectralStatistics.number_variance","text":"number_variance(model::Model, l) ‚Üí p::Vector\n\nNumber variance.\n\n\n\n\n\nnumber_variance(spect::S, x::Vector{T}) ‚Üí s::Vector\n\nNumber variance.\n\n\n\n\n\n","category":"function"},{"location":"API/#SpectralStatistics.rigidity","page":"API","title":"SpectralStatistics.rigidity","text":"rigidity(model::Model, l::Vector) ‚Üí p::Vector\n\nSpectral rigidity.\n\n\n\n\n\n","category":"function"},{"location":"API/#SpectralStatistics.spectral_form_factor","page":"API","title":"SpectralStatistics.spectral_form_factor","text":"spectral_form_factor(model::Model, t) ‚Üí p::Vector\n\nSpectral form factor.\n\n\n\n\n\nspectral_form_factor(E::Vector{T}, t::T) ‚Üí s::Vector\n\nSpectral form factor.\n\n\n\n\n\n","category":"function"},{"location":"API/#Analytical-models","page":"API","title":"Analytical models","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Poisson\nGOE\nGUE\nGSE\nGamma\nBrody\nBerryRobnik\nBerryRobnikBrody ","category":"page"},{"location":"API/#SpectralStatistics.Poisson","page":"API","title":"SpectralStatistics.Poisson","text":"Poisson <: Model \n\nPoisson is a concrete type used to represent the Poisson model. \n\nDescription\n\nThe Poisson model applies to sequences of independent random variables.  Based on the Berry-Tabor conjecture the spectral statistics (in the semiclassical limit)  of integrable systems are described by this model.\n\nAttributes\n\nThis model has no attributes.\n\nAPI\n\nThe following spectral statistcs can be evaluated for this model:\n\nlevel_spacing_pdf\nlevel_spacing_cdf\nlevel_spacing_u\nnumber_variance\nrigidity\nspectral_form_factor\n\n\n\n\n\n","category":"type"},{"location":"API/#SpectralStatistics.GOE","page":"API","title":"SpectralStatistics.GOE","text":"GOE <: Model \n\nGOE is a concrete type used to represent the Gaussian Orthogonal Ensemble model of random matrix theory. \n\nDescription\n\nBased on the Bohigas-Giannoni-Schmit conjecture this model describes the spectral statistics (in the semiclassical limit)  of chaotic systems, invariant under time-reversal symmetry and without spin 1/2 interactions.\n\nAttributes\n\nThis model has no attributes.\n\nAPI\n\nThe following spectral statistcs can be evaluated for this model:\n\nlevel_spacing_pdf\nlevel_spacing_cdf\nlevel_spacing_u\nnumber_variance\nrigidity\nspectral_form_factor\n\n\n\n\n\n","category":"type"},{"location":"API/#SpectralStatistics.GUE","page":"API","title":"SpectralStatistics.GUE","text":"GUE <: Model \n\nGUE is a concrete type used to represent the Gaussian Unitary Ensemble model of random matrix theory. \n\nDescription\n\nBased on the Bohigas-Giannoni-Schmit conjecture this model describes the spectral statistics (in the semiclassical limit)  of chaotic systems, without time-reversal (or a generalized anti-unitary) symmetry.\n\nAttributes\n\nThis model has no attributes.\n\nAPI\n\nThe following spectral statistcs can be evaluated for this model:\n\nlevel_spacing_pdf\nlevel_spacing_cdf\nlevel_spacing_u\nnumber_variance\nrigidity\nspectral_form_factor\n\n\n\n\n\n","category":"type"},{"location":"API/#SpectralStatistics.GSE","page":"API","title":"SpectralStatistics.GSE","text":"GSE <: Model \n\nGSE is a concrete type used to represent the Gaussian Symplectic Ensemble model of random matrix theory. \n\nDescription\n\nBased on the Bohigas-Giannoni-Schmit conjecture this model describes the spectral statistics (in the semiclassical limit)  of chaotic systems, invariant under time-reversal symmetry and including spin 1/2 interactions.\n\nAttributes\n\nThis model has no attributes.\n\nAPI\n\nThe following spectral statistcs can be evaluated for this model:\n\nlevel_spacing_pdf\nlevel_spacing_cdf\nlevel_spacing_u\nnumber_variance\nrigidity\nspectral_form_factor\n\n\n\n\n\n","category":"type"},{"location":"API/#SpectralStatistics.Gamma","page":"API","title":"SpectralStatistics.Gamma","text":"Gamma <: Model \n\nGamma is a concrete type used to represent the Gamma model. \n\nDescription\n\nThis model represents the gamma distributions. \n\nAttributes\n\ngamma: The level repulsion exponent.\n\nAPI\n\nThe following spectral statistcs can be evaluated for this model:\n\nlevel_spacing_pdf\nlevel_spacing_cdf\n\n\n\n\n\n","category":"type"},{"location":"API/#SpectralStatistics.Brody","page":"API","title":"SpectralStatistics.Brody","text":"Brody <: Model \n\nBrody is a concrete type used to represent the Brody model. \n\nDescription\n\nThis model interpolates between the Poisson (beta=0) and Wigner-Dyson (beta=1) distributions.  It is commonly used to describe systems with some degree of localization. \n\nAttributes\n\nbeta: The level repulsion exponent.\n\nAPI\n\nThe following spectral statistcs can be evaluated for this model:\n\nlevel_spacing_pdf\nlevel_spacing_cdf\nlevel_spacing_u\n\n\n\n\n\n","category":"type"},{"location":"API/#SpectralStatistics.BerryRobnik","page":"API","title":"SpectralStatistics.BerryRobnik","text":"BerryRobnik <: Model\n\nBerryRobnik is a concrete type used to represent the Berry-Robnik model (with two components). \n\nDescription\n\nThis model describes the spectral statistics (in the semiclassical limit)  of systems whose classical phase space features both regular and chaotic motion. These systems are commonly refered to as systems with divided phase space or mixed-type systems. The model rests on the argument that in the semiclassical limit the spectrum subspectra belonging to states that describe  belonging to the states to the distinct types of motion (regular and chaotic) will decompose into separate components. The regular part of the spectrum is modeled by Poisson statistics and the chaotic part by GOE statistics.\n\nAttributes\n\nrho: The Liouville measure of the combined regular component.\n\nAPI\n\nThe following spectral statistcs can be evaluated for this model:\n\nlevel_spacing_pdf\nlevel_spacing_cdf\nlevel_spacing_u\nnumber_variance\n\n\n\n\n\n","category":"type"},{"location":"API/#SpectralStatistics.BerryRobnikBrody","page":"API","title":"SpectralStatistics.BerryRobnikBrody","text":"BerryRobnikBrody <: Model \n\nBerryRobnikBrody is a concrete type used to represent the Berry-Robnik-Brody model. \n\nDescription\n\nThis model is the Berry-Robnik model (see BerryRobnik) where instead of the GOE the Brody model is used for the chaotic part.    It is commonly used to describe systems with a divided phase space as well as some degree of localization. \n\nAttributes\n\nrho: The Liouville measure of the combined regular component.\nbeta: The level repulsion exponent.\n\nAPI\n\nThe following spectral statistcs can be evaluated for this model:\n\nlevel_spacing_pdf\nlevel_spacing_cdf\nlevel_spacing_u\n\n\n\n\n\n","category":"type"},{"location":"API/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"unfold_spectrum\nfit_model","category":"page"},{"location":"API/#SpectralStatistics.unfold_spectrum","page":"API","title":"SpectralStatistics.unfold_spectrum","text":"unfold_spectrum(spect::DataSample, f::Function) ‚Üí unfolded::UnfoldedSpectrum\n\nReturn the unfolded spectrum of spect by using the function f  as the smooth part of the integrated density of states.\n\nArguments\n\nspect: Spectrum to be unfolded.\nf(x) : Function modeling the smooth part of the integrated density of states, where the argument x is the energy.\n\nReturns\n\nunfolded : The unfolded spectrum as an instance of type UnfoldedSpectrum.\n\n\n\n\n\nunfold_spectrum(spect::DataSample, n::Int) ‚Üí unfolded::UnfoldedSpectrum\n\nReturn the unfolded spectrum of spect by fitting a polynomial of degree n  to the integrated density of states.\n\nArguments\n\nn : Degree of polynomial moddeling the smooth part of the integrated density of states.\n\n\n\n\n\nunfold_spectrum(spect::DataSample, n::Int, cut_values) ‚Üí unfolded::UnfoldedSpectrum\n\nReturn the unfolded spectrum of spect by piecewise fitting polynomials of degree n  to the integrated density of states.\n\nArguments\n\ncut_values : Relative positions of the cuts between the spectral pieces.  \n\n\n\n\n\n","category":"function"},{"location":"API/#SpectralStatistics.fit_model","page":"API","title":"SpectralStatistics.fit_model","text":"fit_model(spectrum, model, statistic::Function; limits=(0.0, 5.0), grid=200,\nstatargs=Dict())) ‚Üí model\n\nReturn the model with the parameters adjusted to optimally fit the statistic computed from the spectrum. The statistic is computed on a linear grid and then fitted with the apropriate analytical expression from the model.\n\nArguments\n\nspectrum: The energy spectrum, given as an instance of subtype DataSample compatible with the statistic.\nmodel: The model we wish to fit, given as an instance of subtype Model.\nstatistic: The function used to compute the spectral statistic we wish to fit.\n\nKeyword arguments\n\nlimits=(0.0, 5.0) : Limitng values of the argumet of the statistic we wish to compute.\ngrid=200 : Evaluation grid of the statistic.\n\nReturns\n\nmodel : A new instance of the model with adjusted parameters.\n\n\n\n\n\n","category":"function"}]
}
