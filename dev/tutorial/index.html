<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · SpectralStatistics.jl</title><meta name="title" content="Tutorial · SpectralStatistics.jl"/><meta property="og:title" content="Tutorial · SpectralStatistics.jl"/><meta property="twitter:title" content="Tutorial · SpectralStatistics.jl"/><meta name="description" content="Documentation for SpectralStatistics.jl."/><meta property="og:description" content="Documentation for SpectralStatistics.jl."/><meta property="twitter:description" content="Documentation for SpectralStatistics.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpectralStatistics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Core-components"><span>Core components</span></a></li><li><a class="tocitem" href="#Preparing-and-unfolding-spectra"><span>Preparing and unfolding spectra</span></a></li><li><a class="tocitem" href="#Computing-spectral-statistics"><span>Computing spectral statistics</span></a></li><li><a class="tocitem" href="#Using-models"><span>Using models</span></a></li></ul></li><li><a class="tocitem" href="../API/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/clozej/SpectralStatistics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/clozej/SpectralStatistics.jl/blob/main/docs/src/tutorial.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>This section will guide you through everything you need to know for getting started with the SpectralStatistics.jl package.</p><div class="admonition is-info"><header class="admonition-header">Quantum chaos</header><div class="admonition-body"><p>To learn more about spectral statistics and quantum chaos in general the books <em>Quantum Chaos: An Introduction</em> by H.-J. Stöckmann  and <em>Quantum Signatures of Chaos</em> by F. Haake are a good place to start.</p></div></div><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>SpectralStatistics can be installed using the Julia package manager. Simply run:</p><pre><code class="language-julia hljs">using Pkg; Pkg.add(&quot;SpectralStatistics&quot;)</code></pre><p>This will instal the package to your current environment. To use it run:</p><pre><code class="language-julia hljs">using SpectralStatistics</code></pre><p>in your Julia session.</p><h2 id="Core-components"><a class="docs-heading-anchor" href="#Core-components">Core components</a><a id="Core-components-1"></a><a class="docs-heading-anchor-permalink" href="#Core-components" title="Permalink"></a></h2><p>There are three major components of the package:</p><ol><li><p>Types that represent spectral data, for example <a href="../API/#SpectralStatistics.UnfoldedSpectrum"><code>UnfoldedSpectrum</code></a> and <a href="../API/#SpectralStatistics.RealSpectrum"><code>RealSpectrum</code></a>. These are subtypes of the <a href="../API/#SpectralStatistics.DataSample"><code>DataSample</code></a> abstract type.</p></li><li><p>Types that represent analytical models of spectral statistics for example <a href="../API/#SpectralStatistics.Poisson"><code>Poisson</code></a> and <a href="../API/#SpectralStatistics.GOE"><code>GOE</code></a>. These are subtypes of the <a href="../API/#SpectralStatistics.Model"><code>Model</code></a> abstract type.</p></li><li><p>Functions that compute the spectral statistics for example <a href="../API/#SpectralStatistics.level_spacing_pdf"><code>level_spacing_pdf</code></a>. They can be used either to compute the spectral statistics from a spectrum by imputing the data or evaluate an analytical expression from a model. </p></li></ol><p>The package also includes convenience codes for fitting the models to data and plotting.</p><h2 id="Preparing-and-unfolding-spectra"><a class="docs-heading-anchor" href="#Preparing-and-unfolding-spectra">Preparing and unfolding spectra</a><a id="Preparing-and-unfolding-spectra-1"></a><a class="docs-heading-anchor-permalink" href="#Preparing-and-unfolding-spectra" title="Permalink"></a></h2><p>Infinite potential wells are usually one of the first example quantum systems one encounters when learning quantum mechanics. We will analyze the spectrum of a two-dimensional well, namely the rectangular quantum billiard. Let us take a rectangle with sides <span>$a$</span> and <span>$b$</span>. The energy levels are given by </p><p class="math-container">\[E_{n_x, n_y} = \frac{\pi^2}{2}\left(\left(\frac{n_x}{a}\right)^2+\left(\frac{n_y}{b}\right)^2\right),\]</p><p>where <span>$n_x$</span> and <span>$n_y$</span> are integer quantum numbers and the particle mass <span>$m=1$</span> and <span>$\hbar=1$</span>. We will also fix <span>$a=1$</span> and define the ratio <span>$\chi=b/a$</span>. We define a function that returns the first <span>$N$</span> levels:</p><pre><code class="language-julia hljs">H(nx,ny,a,b) = 0.5*pi^2.0*( (nx/a)^2.0 + (ny/b)^2.0 )

function rectangle_spectrum(N; chi = 1.0*MathConstants.golden)
    M = Int(round(10*chi*sqrt(N)))
    spect = [H(i,j,1.0,chi) for i in 1:M for j in 1:M]
    return sort(spect)[1:N]
end</code></pre><p>We set the parameter <span>$\chi$</span> to the golden ratio by default. Let us compute the spectrum of the first 50000 levels:</p><pre><code class="language-julia hljs">spect = rectangle_spectrum(50000)</code></pre><p>The SpectralStatistics.jl package uses the <code>RealSpectrum</code> container to represent raw spectral data. This is the data we would obtain form an experiment or a numerical simulation. We pass our data to the container:</p><pre><code class="language-julia hljs">real = RealSpectrum(spect)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RealSpectrum([6.819728913394972, 12.474509051945848, 21.624135515029007, 21.89914261619731, 27.278915653579887, 35.09362960614936, 36.703549217831345, 46.2981465177524, 49.89803620778339, 51.95292665630328  …  195147.95351392683, 195154.95466509456, 195157.8230231368, 195160.41951171888, 195162.7524223028, 195163.95671701664, 195172.094621494, 195173.07546120507, 195176.23834529548, 195184.50469042303])</code></pre><p>Some spectral statistics may be computed directly from this data. Usually, to compare the universal statistical properties of the spectra of different systems, the spectra must first be normalized in an appropriate way. This process is called spectral unfolding. The density of states varies from system to system. The spectral staircase function number of levels up to some energy</p><p class="math-container">\[N(E) := \#\{n|E_n&lt;E\}.\]</p><p>We are mainly interested in the fluctuations of levels around the local mean that turn out to have universal properties that are related to the dynamics. One way to unfold the spectrum, is to fit a smooth curve <span>$F(E)$</span> to the spectral staircase. This represents the integrated density of states. One of the common ways of unfolding the spectrum is to transform the spectral data by</p><p class="math-container">\[e_n = F(E_n).\]</p><p>The new energies <span>${e_n}$</span> are called the unfolded energies. The function <code>unfold_spectrum</code> can be used to unfold a real spectrum. It returns a new spectrum of type <code>UnfoldedSpectrum</code>. Polynomials of n-th degrees are commonly used as unfolding functions. We will use a second degree polynomial to unfold the billiard spectrum. We simply call:</p><pre><code class="language-julia hljs">unfolded = unfold_spectrum(real, 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">UnfoldedSpectrum([1.7304337718739802, 3.165267902890798, 5.4868817772119165, 5.55666177465583, 6.9217202122444155, 8.904620866692046, 9.313121256933172, 11.7476534913204, 12.661090390147544, 13.182499098571578  …  49982.45121828218, 49984.24270748431, 49984.97667671628, 49985.64107847636, 49986.23803448438, 49986.546194952956, 49988.62855824935, 49988.879539758025, 49989.688872029874, 49991.80409828991])</code></pre><p>For convenience it is possible to call <code>unfold_spectrum</code> with an integer as the second parameter to use a polynomial as the fitting function. In general any julia function (its first parameter must be the energy) may be passed as the second parameter of <code>unfold_spectrum</code> and it will be automatically fitted and used as the unfolding function. We have unfolded the spectrum and can now continue with analyzing the spectral statistics.</p><h2 id="Computing-spectral-statistics"><a class="docs-heading-anchor" href="#Computing-spectral-statistics">Computing spectral statistics</a><a id="Computing-spectral-statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-spectral-statistics" title="Permalink"></a></h2><p>Let us compute one of the most important and commonly used spectral statistics - the nearest-neighbor level spacing distribution. The level spacings are simply the differences between consecutive energies in the spectrum</p><p class="math-container">\[s_i=e_{i+1}-e_i.\]</p><p>If the spectrum is unfolded the mean level spacing will be equal to 1. It is possible to compute the level spacings with the <code>level_spacing</code> function. Let us check the unfolding by calling:</p><pre><code class="language-julia hljs">using Statistics
mean(level_spacing(unfolded))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.9998214697197552</code></pre><p>We see the mean level spacing is indeed approximately equal to 1. Next we are interested in the probability distribution of finding a certain level spacing in the unfolded spectrum. The <code>level_spacing_pdf</code> computes the probability density function (as a histogram) of the level spacing:</p><pre><code class="language-julia hljs">s = collect(0.0:0.05:5.0)
p = level_spacing_pdf(unfolded, s)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">101-element Vector{Float64}:
 1.0551520151310891
 0.9955934727056881
 0.9400591561198417
 0.8700376265116001
 0.8607819070806251
 0.7577617255880398
 0.6978007605786847
 0.7396527093100459
 0.6583633473510528
 0.6732529829574044
 ⋮
 0.01167025493470677
 0.008853296847018929
 0.010865409766796345
 0.008450874263063523
 0.009658142014930083
 0.004829071007464871
 0.008853296847018929
 0.0044266484235096215
 0.0048290710074650415</code></pre><p>the second parameter must be a <code>Vector</code> of evaluation points. We can plot the result by using the excellent <a href="https://docs.makie.org/stable/">Makie</a> library:</p><pre><code class="language-julia hljs">using CairoMakie
f = Figure(resolution = (640,360))
ax = Axis(f[1,1], xlabel=L&quot;s&quot;, ylabel=L&quot;P(s)&quot;)
lines!(ax,s,p)</code></pre><p><img src="../lsplot.svg" alt/></p><h2 id="Using-models"><a class="docs-heading-anchor" href="#Using-models">Using models</a><a id="Using-models-1"></a><a class="docs-heading-anchor-permalink" href="#Using-models" title="Permalink"></a></h2><p>We will now compare the results with some analytical models. The library features many of the most used ones. For a complete list see the <a href="../API/#API">API</a> section. Let us compare the level spacings with the Poisson model. To initialize a model we call its constructor:</p><pre><code class="language-julia hljs">poisson = Poisson()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Poisson()</code></pre><p>We can check the characteristics of the model in the documentation <a href="../API/#SpectralStatistics.Poisson"><code>Poisson</code></a>, where we read that it describes the spectral statistics of an integrable system.   This is a parameter-less model so the constructor takes no arguments. The level spacing probability density function for the Poisson model is an exponential decay</p><p class="math-container">\[P(s)=\exp(-s).\]</p><p>We can evaluate the analytical expression by calling the <code>level_spacing_pdf</code> on the model in the same way as we did for the spectral data:</p><pre><code class="language-julia hljs">p_poisson = level_spacing_pdf(poisson, s)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">101-element Vector{Float64}:
 1.0
 0.951229424500714
 0.9048374180359595
 0.8607079764250578
 0.8187307530779818
 0.7788007830714049
 0.7408182206817179
 0.7046880897187134
 0.6703200460356393
 0.6376281516217733
 ⋮
 0.010051835744633586
 0.009561601930543505
 0.009095277101695816
 0.008651695203120634
 0.00822974704902003
 0.007828377549225773
 0.007446583070924338
 0.0070834089290521185
 0.006737946999085467</code></pre><p>Let us add the result to the plot:</p><pre><code class="language-julia hljs">lines!(ax,s,p_poisson)</code></pre><p><img src="../lsplot2.svg" alt/></p><p>We see the model curve fits the data nicely and we can conclude the rectangular billiard belongs to the class of integrable systems. If this was a real application we might be satisfied with the analysis. However, just to demonstrate how to fit more complicated models we will try describing the data with another. Many models are actually parametric families, where the parameters are given as fields of the Julia type that codes the model. Let&#39;s use the <a href="../API/#SpectralStatistics.Brody"><code>Brody</code></a> model. From the documentation we see this model interpolates between the <code>Poisson</code> and <code>GOE</code> models as the parameter <code>:beta</code> goes form 0.0 to 1.0. We initialize the model by calling:</p><pre><code class="language-julia hljs">brody = Brody()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Brody(1.0)</code></pre><p>Here we initialized the model with the default value of the parameter. We can see from the output this is equal to 1.0. To initialize the model with a different value of the parameter we simply call the constructor with the selected value as an argument: </p><pre><code class="language-julia hljs">brody = Brody(0.2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Brody(0.2)</code></pre><p>Some models might posses several parameters. One example is the <a href="../API/#SpectralStatistics.BerryRobnikBrody"><code>BerryRobnikBrody</code></a> model. To check all the names of the parameters we can use the <code>fieldnames</code> function on the associated type:</p><pre><code class="language-julia hljs">fieldnames(BerryRobnikBrody)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(:rho, :beta)</code></pre><p>We see the parameters of this model are called <code>rho</code> and <code>beta</code>. To make sure we do not mix up the order of the parameters we may also initialize the model with keyword arguments corresponding to the names of the parameters:</p><pre><code class="language-julia hljs">brb = BerryRobnikBrody(beta=0.1,rho=0.5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BerryRobnikBrody(0.5, 0.1)</code></pre><p>Note from the output that the parameters are initialized correctly regardless of the input order. Usually we want to fit the model to some data in order to find the optimal values of the parameters. We can do this with the <code>fit_model</code> function. This will return a new instance of the model with the adjusted fitting parameter. Since, we have the level spacings already stored we can call:</p><pre><code class="language-julia hljs">brody = fit_model(brody, level_spacing_pdf, s, p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Brody(4.583872408366135e-6)</code></pre><p>Here we chose to overwrite the variable <code>brody</code> with the a new instance with an adjusted parameter value. The second parameter is the statistic we wish to fit. We may also call:</p><pre><code class="language-julia hljs">brody = fit_model(unfolded, brody, level_spacing_pdf)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Brody(4.08794683246768e-6)</code></pre><p>to compute the statistic directly from the spectrum if we did not do so beforehand. We see that the fitting parameter is almost 0 and it agrees with the Poisson model.</p><p>To learn more about all the features of the library continue by exploring the <a href="../API/#API">API</a> section.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../API/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 4 December 2023 17:52">Monday 4 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
